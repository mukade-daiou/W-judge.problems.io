{"submission_id": "2091", "source": "# include <iostream>\r\n# include <algorithm>\r\n#include <array>\r\n# include <cassert>\r\n#include <cctype>\r\n#include <climits>\r\n#include <numeric>\r\n# include <vector>\r\n# include <string>\r\n# include <set>\r\n# include <map>\r\n# include <cmath>\r\n# include <iomanip>\r\n# include <functional>\r\n# include <tuple>\r\n# include <utility>\r\n# include <stack>\r\n# include <queue>\r\n# include <list>\r\n# include <bitset>\r\n# include <complex>\r\n# include <chrono>\r\n# include <random>\r\n# include <limits.h>\r\n# include <unordered_map>\r\n# include <unordered_set>\r\n# include <deque>\r\n# include <cstdio>\r\n# include <cstring>\r\n#include <stdio.h>\r\n#include<time.h>\r\n#include <stdlib.h>\r\n#include <cstdint>\r\n#include <cfenv>\r\n#include<fstream>\r\n//#include <bits/stdc++.h>\r\nusing namespace std;\r\nusing LL = long long;\r\nusing ULL = unsigned long long;\r\nlong long MOD = 1000000000 + 7;\r\nconstexpr long long INF = numeric_limits<LL>::max();\r\nconst double PI = acos(-1);\r\n#define fir first\r\n#define sec second\r\n#define thi third\r\n#define debug(x) cerr<<#x<<\": \"<<x<<'\\n'\r\ntypedef pair<LL, LL> Pll;\r\ntypedef pair<LL, pair<LL, LL>> Ppll;\r\ntypedef pair<LL, pair<LL, bitset<100001>>> Pbll;\r\ntypedef pair<LL, pair<LL, vector<LL>>> Pvll;\r\ntypedef pair<LL, LL> Vec2;\r\nstruct Tll { LL first, second, third; };\r\nstruct Fll { LL first, second, third, fourd; };\r\ntypedef pair<LL, Tll> Ptll;\r\n#define rep(i,rept) for(LL i=0;i<rept;i++)\r\n#define Mfor(i,mf) for(LL i=mf-1;i>=0;i--)\r\n\r\nLL h, w, n, m, k, t, s, p,q, last, cnt, sum, ans, dp[1000][1000], a[110000], b[20000];\r\nstring str, ss;\r\nbool f[1100];\r\nchar c;\r\nint di[4][2] = { { 0,1 },{ 1,0 },{ 0,-1 },{ -1,0 } };\r\nstruct Edge { LL to, cost; };\r\nvector<vector<Edge>>vec;\r\nvector<Pll>v[110000];\r\nmap<string,LL>ma;\r\nmultiset<LL>st;\r\nvoid YN(bool f) {\r\n\tif (f)\r\n\t\tcout << \"YES\" << endl;\r\n\telse\r\n\t\tcout << \"NO\" << endl;\r\n}\r\nvoid yn(bool f) {\r\n\tif (f)\r\n\t\tcout << \"Yes\" << endl;\r\n\telse\r\n\t\tcout << \"No\" << endl;\r\n}\r\nstruct Seg {\r\n\tLL n;\r\n\tvector<LL>node;\r\n\tSeg(LL n_) {\r\n\t\tn = 1; while (n < n_)n *= 2;\r\n\t\tnode.resize(n * 2 - 1);\r\n\t\trep(i, node.size())node[i] = INF;\r\n\t\t//\u533a\u9593\u6700\u5c0f\u306a\u3069\u306e\u6642\r\n\t\t//rep(i, n * 2 - 1)lazy[i] = -1;\r\n\t}\r\n\tvoid update(LL i, LL x) {\r\n\t\ti = i + n - 1;\r\n\t\tnode[i] = x;\r\n\t\twhile (i > 0) {\r\n\t\t\ti = (i - 1) / 2;\r\n\t\t\tnode[i] = min(node[i * 2 + 1], node[i * 2 + 2]);\r\n\t\t}\r\n\t}\r\n\tLL find(LL i, LL a, LL b, LL l, LL r) {\r\n\t\tif (b< l || r < a)return INF;\r\n\t\tif (l <= a && b <= r)return node[i];\r\n\t\treturn min(find(i * 2 + 1, a, (a + b) / 2, l, r), find(i * 2 + 2, (a + b + 1) / 2, b, l, r));\r\n\t}\r\n};\r\nSeg seg(110000);\r\nstruct HLD {\r\n\tLL n, pos;\r\n\tvector<vector<LL> > G;\r\n\tvector<LL> vid, head, sub, hvy, par, dep, inv, type;\r\n\r\n\tHLD() {}\r\n\tHLD(LL sz) :\r\n\t\tn(sz), pos(0), G(n),\r\n\t\tvid(n, -1), head(n), sub(n, 1), hvy(n, -1),\r\n\t\tpar(n), dep(n), inv(n), type(n) {}\r\n\r\n\tvoid add_edge(LL u, LL v) {\r\n\t\tG[u].push_back(v);\r\n\t\tG[v].push_back(u);\r\n\t}\r\n\r\n\tvoid build(vector<LL> rs = vector<LL>(1, 0)) {\r\n\t\tLL c = 0;\r\n\t\tfor (LL r : rs) {\r\n\t\t\tdfs(r);\r\n\t\t\tbfs(r, c++);\r\n\t\t}\r\n\t\trep(i, n)\r\n\t\t\tseg.update(vid[i], a[i]);\r\n\t}\r\n\r\n\tvoid dfs(LL rt) {\r\n\t\tusing T = pair<LL, LL>;\r\n\t\tstack<T> st;\r\n\t\tpar[rt] = -1;\r\n\t\tdep[rt] = 0;\r\n\t\tst.emplace(rt, 0);\r\n\t\twhile (!st.empty()) {\r\n\t\t\tLL v = st.top().first;\r\n\t\t\tLL &i = st.top().second;\r\n\t\t\tif (i<(LL)G[v].size()) {\r\n\t\t\t\tLL u = G[v][i++];\r\n\t\t\t\tif (u == par[v]) continue;\r\n\t\t\t\tpar[u] = v;\r\n\t\t\t\tdep[u] = dep[v] + 1;\r\n\t\t\t\tst.emplace(u, 0);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tst.pop();\r\n\t\t\t\tLL res = 0;\r\n\t\t\t\tfor (LL u : G[v]) {\r\n\t\t\t\t\tif (u == par[v]) continue;\r\n\t\t\t\t\tsub[v] += sub[u];\r\n\t\t\t\t\tif (res<sub[u]) res = sub[u], hvy[v] = u;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tvoid bfs(LL r, LL c) {\r\n\t\tLL &k = pos;\r\n\t\tqueue<LL> q({ r });\r\n\t\twhile (!q.empty()) {\r\n\t\t\tLL h = q.front(); q.pop();\r\n\t\t\tfor (LL i = h; i != -1; i = hvy[i]) {\r\n\t\t\t\ttype[i] = c;\r\n\t\t\t\tvid[i] = k++;\r\n\t\t\t\tinv[vid[i]] = i;\r\n\t\t\t\thead[i] = h;\r\n\t\t\t\tfor (LL j : G[i])\r\n\t\t\t\t\tif (j != par[i] && j != hvy[i]) q.push(j);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// for_each(vertex)\r\n\t// [l,r] <- attention!!\r\n\tbool for_each(LL u, LL v, LL x, const function<bool(LL, LL,LL)>& f) {\r\n\t\twhile (1) {\r\n\t\t\tif (vid[u] > vid[v]) swap(u, v);\r\n\t\t\tif (f(max(vid[head[v]], vid[u]), vid[v], x)) {\r\n\t\t\t\treturn 0;\r\n\t\t\t}\r\n\t\t\tif (head[u] != head[v]) v = par[head[v]];\r\n\t\t\telse break;\r\n\t\t}\r\n\t\treturn 1;\r\n\t}\r\n\r\n\tLL lca(LL u, LL v) {\r\n\t\twhile (1) {\r\n\t\t\tif (vid[u]>vid[v]) swap(u, v);\r\n\t\t\tif (head[u] == head[v]) return u;\r\n\t\t\tv = par[head[v]];\r\n\t\t}\r\n\t}\r\n\r\n\tLL distance(LL u, LL v) {\r\n\t\treturn dep[u] + dep[v] - 2 * dep[lca(u, v)];\r\n\t}\r\n};\r\n\r\nint main() {\r\n\tcin >> n;\r\n\tHLD hld(n);\r\n\trep(i, n-1) {\r\n\t\tLL x, y;\r\n\t\tcin >> x >> y;\r\n\t\tx--, y--;\r\n\t\thld.add_edge(x,y);\r\n\t}\r\n\trep(i, n) {\r\n\t\tcin >> a[i];\r\n\t}\r\n\thld.build();\r\n\r\n\trep(i, n) \r\n\tv[a[i]].push_back(Pll(hld.distance(0, i), i));\r\n\r\n\tfor (int i = 1; i <= 100000;i++) {\r\n\t\tif (v[i].size() < 2)continue;\r\n\t\tsort(v[i].begin(), v[i].end());\r\n\t\tLL lc = 0, ver = v[i][v[i].size() - 1].sec, u = -1;\r\n\t\tsum = 0;\r\n\t\tMfor(j, v[i].size() - 1) {\r\n\t\t\tlc = hld.lca(ver, v[i][j].sec);\r\n\t\t\tif (u == -1) {\r\n\t\t\t\tif (min(hld.dep[ver], hld.dep[v[i][j].sec]) != hld.dep[lc]) {\r\n\t\t\t\t\tu = v[i][j].sec;\r\n\t\t\t\t\tsum++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tif (min(hld.dep[u], hld.dep[v[i][j].sec]) != hld.dep[u]) {\r\n\t\t\t\t\tsum++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (sum > 1) {\r\n\t\t\tcout << \"No\" << endl;\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t\tif (u == -1) {\r\n\t\t\tu = v[i][0].sec;\r\n\t\t}\r\n\t\tif (!hld.for_each(ver, u, i, [&](LL x, LL y, LL i) {\r\n\t\t\treturn seg.find(0, 0, seg.n - 1, x, y) < i;})) {\r\n\t\t\tcout << \"No\" << endl;\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t}\r\n\tstd::cout << \"Yes\" << std::endl;\r\n\treturn 0;\r\n}", "problem_id": "113", "problem_title": "(800)\u6728\u4e0a\u306e\u7a7a\u8ad6", "datetime": "2018-08-23 22:53:20", "lang": "C++", "user": "Teacher", "sample_io": ["Accepted", "WrongAnswer"], "result": "WrongAnswer", "testcase": [{"result": "WrongAnswer", "max_score": "800", "io_result": ["Accepted", "Accepted", "Accepted", "Accepted", "Accepted", "Accepted", "Accepted", "Accepted", "Accepted", "Accepted", "Accepted", "Accepted", "Accepted", "Accepted", "Accepted", "Accepted", "Accepted", "Accepted", "WrongAnswer"]}], "score": "0", "max_score": "800"}