{"submission_id": "1166", "source": "# include <iostream>\r\n# include <algorithm>\r\n#include <array>\r\n# include <cassert>\r\n#include <cctype>\r\n#include <climits>\r\n#include <numeric>\r\n# include <vector>\r\n# include <string>\r\n# include <set>\r\n# include <map>\r\n# include <cmath>\r\n# include <iomanip>\r\n# include <functional>\r\n# include <tuple>\r\n# include <utility>\r\n# include <stack>\r\n# include <queue>\r\n# include <list>\r\n# include <bitset>\r\n# include <complex>\r\n# include <chrono>\r\n# include <random>\r\n# include <limits.h>\r\n# include <unordered_map>\r\n# include <unordered_set>\r\n# include <deque>\r\n# include <cstdio>\r\n# include <cstring>\r\n#include <stdio.h>\r\n#include<time.h>\r\n#include <stdlib.h>\r\n#include <cstdint>\r\n#include <cfenv>\r\n\r\n//#include <bits/stdc++.h>\r\nusing namespace std;\r\nusing LL = long long;\r\nusing ULL = unsigned long long;\r\nlong long MOD = 1000000000 + 7;\r\nconstexpr long long INF = numeric_limits<LL>::max();\r\nconst double PI = acos(-1);\r\n#define fir first\r\n#define sec second\r\n#define thi third\r\n#define debug(x) cerr<<#x<<\": \"<<x<<'\\n'\r\ntypedef pair<LL, LL> Pll;\r\ntypedef pair<LL, pair<LL, LL>> Ppll;\r\ntypedef pair<LL, pair<LL, bitset<100001>>> Pbll;\r\ntypedef pair<LL, pair<LL, vector<LL>>> Pvll;\r\ntypedef pair<LL, LL> Vec2;\r\nstruct Tll { LL first, second, third; };\r\nstruct Fll { LL first, second, third, fourd; };\r\ntypedef pair<LL, Tll> Ptll;\r\n#define rep(i,rept) for(LL i=0;i<rept;i++)\r\n#define Mfor(i,mf) for(LL i=mf-1;i>=0;i--)\r\nLL h, w, n, m, k, t, s, q, last, cnt, sum, ans, dp[11000][11000];\r\nTll a[101000], b[110000];\r\nstring str, ss = \"AMAGAERU\";\r\nbool f;\r\nchar c;\r\nint di[4][2] = { { 0,1 },{ 1,0 },{ 0,-1 },{ -1,0 } };\r\nstruct Edge { LL to, cost; };\r\nvector<LL>vec;\r\nvector<Pll>v[200000];\r\nmap<string, LL>ma;\r\nmap<string, LL>ma2;\r\nset<LL>st;\r\nvoid YN(bool f) {\r\n\tif (f)\r\n\t\tcout << \"YES\" << endl;\r\n\telse\r\n\t\tcout << \"NO\" << endl;\r\n}\r\nvoid yn(bool f) {\r\n\tif (f)\r\n\t\tcout << \"Yes\" << endl;\r\n\telse\r\n\t\tcout << \"No\" << endl;\r\n}\r\n\r\n//\r\n// a[0],a[1],a[2],...,a[k],...\r\n//\r\ntemplate <typename T>\r\nstruct node_t {\r\n\tT val;         // \u5024\r\n\tnode_t *lch;\r\n\tnode_t *rch;\r\n\tdouble  pri;   // \u512a\u5148\u5ea6\r\n\tint     cnt;   // \u90e8\u5206\u6728\u306e\u30b5\u30a4\u30ba\r\n\tT       min_val;\r\n\tT       lazy_val;\r\n\tbool    lazy, rev;\r\n\tnode_t(T v, double p) : val(v), lch(nullptr), rch(nullptr),\r\n\t\tpri(p), cnt(1), min_val(v),\r\n\t\tlazy_val(0), lazy(false), rev(false) {}\r\n\t~node_t() {\r\n\t\tdelete lch;\r\n\t\tdelete rch;\r\n\t}\r\n\tstatic void push(node_t *t) {\r\n\t\tif (!t)\r\n\t\t\treturn;\r\n\t\tif (t->lazy)\r\n\t\t{\r\n\t\t\tt->val += t->lazy_val;\r\n\t\t\tt->min_val += t->lazy_val;\r\n\t\t\tif (t->lch)\r\n\t\t\t{\r\n\t\t\t\tt->lch->lazy = true;\r\n\t\t\t\tt->lch->lazy_val += t->lazy_val;\r\n\t\t\t}\r\n\t\t\tif (t->rch)\r\n\t\t\t{\r\n\t\t\t\tt->rch->lazy = true;\r\n\t\t\t\tt->rch->lazy_val += t->lazy_val;\r\n\t\t\t}\r\n\t\t\tt->lazy_val = 0;\r\n\t\t\tt->lazy = false;\r\n\t\t}\r\n\t\tif (t->rev)\r\n\t\t{\r\n\t\t\tswap(t->lch, t->rch);\r\n\t\t\tif (t->lch)t->lch->rev ^= true;\r\n\t\t\tif (t->rch)t->rch->rev ^= true;\r\n\t\t\tt->rev = false;\r\n\t\t}\r\n\t}\r\n\tstatic int count(node_t *t) { return t ? t->cnt : 0; }\r\n\tstatic T Min(node_t *t) { return t ? t->min_val : std::numeric_limits<T>::max(); }\r\n\tstatic node_t *update(node_t *t) {\r\n\t\tassert(t != nullptr);\r\n\t\tpush(t);\r\n\t\tt->cnt = count(t->lch) + count(t->rch) + 1;\r\n\t\tpush(t->lch);\r\n\t\tpush(t->rch);\r\n\t\tt->min_val = std::min({ (T)Min(t->lch), (T)Min(t->rch), t->val });\r\n\t\treturn t;\r\n\t}\r\n\tstatic node_t *merge(node_t *l, node_t *r) {\r\n\t\tif (!l || !r)\r\n\t\t\treturn (!l) ? r : l;\r\n\t\tupdate(l);\r\n\t\tupdate(r);\r\n\t\tif (l->pri > r->pri)\r\n\t\t{\r\n\t\t\tl->rch = merge(l->rch, r);\r\n\t\t\treturn update(l);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tr->lch = merge(l, r->lch);\r\n\t\t\treturn update(r);\r\n\t\t}\r\n\t\tassert(false);\r\n\t\treturn nullptr;\r\n\t}\r\n\t//\r\n\t// node \u3092\u305f\u3069\u308b\u3053\u3068\u306b\u306a\u308b\u3002k\u756a\u76ee\u306e\u30ce\u30fc\u30c9\u3067\u518d\u5e30\u304c\u6b62\u307e\u308b\r\n\t//    [0,1,2,...,k-1,k,...]\r\n\t// -> [0,1,2,...,k-1] [k,...]\r\n\t//\r\n\tstatic std::pair<node_t*, node_t*> split(node_t* t, int k) {\r\n\t\tif (!t)\r\n\t\t\treturn std::make_pair(nullptr, nullptr);\r\n\t\tupdate(t);\r\n\t\tif (k <= count(t->lch))\r\n\t\t{\r\n\t\t\tauto s = split(t->lch, k);\r\n\t\t\tt->lch = s.second;\r\n\t\t\treturn std::make_pair(s.first, update(t));\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tauto s = split(t->rch, k - count(t->lch) - 1);\r\n\t\t\tt->rch = s.first;\r\n\t\t\treturn std::make_pair(update(t), s.second);\r\n\t\t}\r\n\t\tassert(false);\r\n\t\treturn std::make_pair(nullptr, nullptr);\r\n\t}\r\n\tstatic node_t *insert(node_t *t, int k, node_t *new_t) {\r\n\t\tauto s = split(t, k);\r\n\t\treturn merge(merge(s.first, new_t), s.second);\r\n\t}\r\n\tstatic std::pair<node_t*, node_t*> erase(node_t *t, int k) {\r\n\t\tauto sr = split(t, k + 1);\r\n\t\tauto sl = split(sr.first, k);\r\n\t\treturn std::make_pair(merge(sl.first, sr.second), sl.second);\r\n\t}\r\n\tstatic node_t *find(node_t *t, int k) {\r\n\t\tassert(t != nullptr);\r\n\t\tint c = count(t->lch);\r\n\t\tif (k == c)\r\n\t\t\treturn t;\r\n\t\tif (k < c)\r\n\t\t\treturn find(t->lch, k);\r\n\t\treturn find(t->rch, k - c - 1);\r\n\t}\r\n\tstatic void traverse(node_t *t, const std::function<void(node_t *t)> &func) {\r\n\t\tif (!t)\r\n\t\t\treturn;\r\n\t\tif (t->lch)\r\n\t\t\ttraverse(t->lch, func);\r\n\t\tif (t->rch)\r\n\t\t\ttraverse(t->rch, func);\r\n\t\tfunc(t);\r\n\t\treturn;\r\n\t}\r\n};\r\nstatic int seed = 28313234; // seed \u306f\u30c6\u30ad\u30c8\u30fc\u3002\u30c7\u30d0\u30c3\u30b0\u3057\u3084\u3059\u3044\u3088\u3046\u306b\u56fa\u5b9a\u3002\r\ntemplate <typename T>\r\nstruct Treap {\r\n\ttypedef node_t<T> node;\r\n\tstd::function<double(void)> dice_;\r\npublic:\r\n\tnode * root_;\r\n\tTreap() : root_(nullptr) {\r\n\t\tdice_ = std::bind(std::uniform_real_distribution<double>(0.000, 1.000), std::mt19937(seed));\r\n\t}\r\n\t~Treap() {}\r\n\tvoid insert(int k, T val) {\r\n\t\troot_ = node::insert(root_, k, new node(val, dice_()));\r\n\t}\r\n\t// value based\r\n\tint upper_bound(T val) {\r\n\t\tstd::function<int(node*, int)> F = [&](node *s, int left)->int {\r\n\t\t\tassert(s != nullptr);\r\n\t\t\tif (val < s->val)\r\n\t\t\t{\r\n\t\t\t\tif (!s->lch)\r\n\t\t\t\t\treturn left;\r\n\t\t\t\telse\r\n\t\t\t\t\treturn F(s->lch, left);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tint c = node::count(s->lch);\r\n\t\t\t\tif (!s->rch)\r\n\t\t\t\t\treturn (left + (c + 1));\r\n\t\t\t\telse\r\n\t\t\t\t\treturn F(s->rch, left + c + 1);\r\n\t\t\t}\r\n\t\t};\r\n\t\tif (!root_)\r\n\t\t\treturn 0;\r\n\t\treturn F(root_, 0);\r\n\t}\r\n\tvoid insert(T val) {//val\u3092\u6301\u3064\u30ce\u30fc\u30c9\u3092insert\u3059\u308b\r\n\t\tinsert(upper_bound(val), val);\r\n\t}\r\n\tvoid erase(int k) {\r\n\t\tnode *p;\r\n\t\tstd::tie(root_, p) = node::erase(root_, k);\r\n\t\tp->lch = p->rch = nullptr;\r\n\t\tdelete p;\r\n\t}\r\n\tT find(int k) {//k\u756a\u76ee\u306b\u5927\u304d\u3044\u30ce\u30fc\u30c9(0\u304b\u3089\u306f\u3058\u307e\u308b)\r\n\t\tif (!(0 <= k && k < node::count(root_)))return -1;\r\n\t\tnode *p = node::find(root_, k);\r\n\t\treturn p->val;\r\n\t}\r\n\t// shift for [l,r] \u533a\u9593\u306a\u3044\u306e\u8981\u7d20\u3092\u4e00\u3064\u305a\u3089\u3059\u3002\r\n\tvoid shift(int l, int r) {\r\n\t\tr++;\r\n\t\tif (l == r - 1) return;\r\n\t\tassert(l<r);\r\n\t\tauto sr = node::split(root_, r);\r\n\t\tauto sl = node::split(sr.first, l);\r\n\t\tauto lr = node::split(sl.second, r - l - 1);\r\n\t\troot_ = node::merge(node::merge(sl.first,\r\n\t\t\tnode::merge(lr.second, lr.first)),\r\n\t\t\tsr.second);\r\n\t}\r\n\tint size() const { return node::count(root_); }\r\n\t// add to [l,r]\r\n\tvoid add(int l, int r, T val) {\r\n\t\tr++;\r\n\t\tassert(l<r);\r\n\t\tauto sr = node::split(root_, r);\r\n\t\tauto sl = node::split(sr.first, l);\r\n\t\tauto lr = sl.second;\r\n\t\tlr->lazy = true;\r\n\t\tlr->lazy_val = val;\r\n\t\troot_ = node::merge(node::merge(sl.first, lr), sr.second);\r\n\t}\r\n\t// reverse at [l,r]\r\n\tvoid reverse(int l, int r) {\r\n\t\tr++;\r\n\t\tassert(l < r);\r\n\t\tauto sr = node::split(root_, r);\r\n\t\tauto sl = node::split(sr.first, l);\r\n\t\tauto lr = sl.second;\r\n\t\tlr->rev = true;\r\n\t\t// \u623b\u3059\r\n\t\troot_ = node::merge(node::merge(sl.first, lr), sr.second);\r\n\t}\r\n\t// min at [l,r]\r\n\tT Min(int l, int r) {\r\n\t\tr++;\r\n\t\tassert(l<r);\r\n\t\tauto sr = node::split(root_, r);\r\n\t\tauto sl = node::split(sr.first, l);\r\n\t\tauto lr = sl.second;\r\n\t\tT val = node::Min(lr);\r\n\t\t// \u623b\u3059\r\n\t\troot_ = node::merge(node::merge(sl.first, lr), sr.second);\r\n\t\treturn val;\r\n\t}\r\n\tT at(int k) {\r\n\t\tassert(0 <= k && k < size());\r\n\t\tauto sr = node::split(root_, k + 1);\r\n\t\tauto sl = node::split(sr.first, k);\r\n\t\tauto lr = sl.second;\r\n\t\tassert(lr != nullptr);\r\n\t\tT val = lr->val;\r\n\t\troot_ = node::merge(node::merge(sl.first, lr), sr.second);\r\n\t\treturn val;\r\n\t}\r\n\tT get(int k) {\r\n\t\tif (0 <= k && k < size())\r\n\t\t\treturn at(k);\r\n\t\treturn INF;\r\n\t}\r\n\tvoid set(int k, T val) {\r\n\t\tauto sr = node::split(root_, k + 1);\r\n\t\tauto sl = node::split(sr.first, k);\r\n\t\tauto lr = sl.second;\r\n\t\tassert(lr != nullptr);\r\n\t\tlr->val = val;\r\n\t\troot_ = node::merge(node::merge(sl.first, lr), sr.second);\r\n\t}\r\n\tvoid _dump(node *t, std::string tab) {\r\n\t\tif (!t)\r\n\t\t\treturn;\r\n\t\tstd::cerr << tab << \" \" << t->val << \" \" << t->cnt << std::endl;\r\n\t\tif (t->lch)\r\n\t\t{\r\n\t\t\t_dump(t->lch, tab + \"L\");\r\n\t\t}\r\n\t\tif (t->rch)\r\n\t\t{\r\n\t\t\t_dump(t->rch, tab + \"R\");\r\n\t\t}\r\n\t}\r\n\tvoid dump() {\r\n\t\tstd::cerr << \"*******\" << std::endl;\r\n\t\t_dump(root_, \"\");\r\n\t\tstd::cerr << std::endl;\r\n\t}\r\n};\r\n\r\nTreap<LL>tr;\r\nint main() {\r\n\tcin >> n;\r\n\trep(i, n) {\r\n\t\tLL x;\r\n\t\tcin >> str;\r\n\t\tif (str == \"ADD\") {\r\n\t\t\tcin >> x;\r\n\t\t\ttr.insert(x);\r\n\t\t}\r\n\t\tif (str == \"OUTPUT\") {\r\n\t\t\tcin >> x;\r\n\t\t\tLL y = tr.get(x - 1);\r\n\t\t\tif (y != INF)\r\n\t\t\t\tcout << y << endl;\r\n\t\t\telse\r\n\t\t\t\tcout << \"Not Exist!\"<<endl;\r\n\t\t}\r\n\t\tif (str == \"DELETE\") {\r\n\t\t\tcin >> x;\r\n\t\t\ttr.erase(x-1);\r\n\t\t}\r\n\t}\r\n\r\n    return 0;\r\n}", "problem_id": "77", "problem_title": "\u79cb\u306e\u7d05\u8449\u72e9\u308a\u7de8", "datetime": "2018-08-07 09:46:34", "lang": "C++", "user": "akusyounin", "sample_io": ["Accepted"], "testcase": [{"result": "Accepted", "max_score": "30", "io_result": ["Accepted", "Accepted", "Accepted", "Accepted"]}, {"result": "Accepted", "max_score": "70", "io_result": ["Accepted", "Accepted", "Accepted", "Accepted", "Accepted"]}], "result": "Accepted", "score": "100", "max_score": "100"}